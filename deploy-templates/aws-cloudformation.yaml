AWSTemplateFormatVersion: "2010-09-09"
Description: >
  1. Make a copy of parameters.env.example and rename it to parameters.env, then populate it with the values appropriate to your environment. CloudFormation will read those values from the file if you pass it on the command line when you create or update the stack. See the parameter definitions below for full instructions.
  2. Navigate to the directory that contains these files and run the following aws cli command:
  aws cloudformation create-stack --stack-name qa-server-cf-container-with-lb \
  --template-body file://./aws-cloudformation.yaml \
  --parameters file://./parameters.env
  3. You will need to validate the ACM certificate after the stack has been created, by creating the DNS record that will appear in the CloudFormation and ACM consoles.
Parameters:
  AWSAccountId:
    Type: String
    Default: ''
    Description: Your AWS Account ID number. Usually a 12-digit number. Required.
  AWSVpcId:
    Type: String
    Default: ''
    Description: Your AWS VPC ID. It should look like vpc-4d4bec2b. Required for load balancer configuration.
  TaskDefinitionName:
    Type: String
    Default: ''
    Description: Name of the task definition and the task definition family. This can be anything you like, but should not contain spaces. It is reused in naming the load balancer and the log groups.
  S3BucketName:
    Type: String
    Default: ''
    Description: Name of the S3 bucket where the environment file resides. This must exist for the application to launch.
  EnvFileName:
    Type: String
    Default: ''
    Description: Name of the environment file. This must exist for the application to launch, and it must be populated with values appropriate to your environment.
  ImageLocation:
    Type: String
    Default: ''
    Description: Full path to the container image for the qa-server application, including repository URL and tag. This must be a repo within Amazon ECR, or a publicly accessible repo. Private repo authentication is not available at this time.
  VolumeId:
    Type: String
    Default: ''
    Description: ID of the volume where the database and authority files are stored. This is an EFS volume that must exist for the application to launch. The EFS volume must contain two access points that are specified in the next two parameters.
  AuthorityAccessPointId:
    Type: String
    Default: ''
    Description: EFS Access Point ID of the volume where the authority files are stored. This will map to the application's authority file volume, and it should contain at least one authority file. If no authority files are found, the application will still launch, and static portions will display, but the Authorities, Check Status, and Monitor Status pages may behave unpredictably.
  DatabaseAccessPointId:
    Type: String
    Default: ''
    Description: EFS Access Point ID of the volume where the database is stored. This can be empty at first launch, and it should be reused in subsequent launches if persistence of the data is desired. 
  DomainName:
    Type: String
    Default: ''
    Description: Domain name to use for the public facing service. This is only used to provision the ACM certificate for the load balancer to serve secure connections. If this is not desired, the certificate resource can be removed from this template, along with the load balancer listener for port 443 that requires the certificate.
Resources:
# TODO: Add a cluster definition and a service definition
  LogGroup:
    Type: AWS::Logs::LogGroup
    Properties: 
      LogGroupName: !Join ["", ["/ecs/", !Ref TaskDefinitionName, "-lb"]]
  TaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties: 
      Family: !Ref TaskDefinitionName
      ContainerDefinitions: 
        - Name: 'qa-server-app'
          Cpu: 0
          EnvironmentFiles: 
            - Type: s3
              Value: !Join ["", ["arn:aws:s3:::", !Ref S3BucketName, "/", !Ref EnvFileName]]
          Essential: True
          Image: !Ref ImageLocation
          Links: 
            - qa-mariadb
          LogConfiguration: 
            LogDriver: awslogs
            Options:
              awslogs-group: !Join ["", ["/ecs/", !Ref TaskDefinitionName, "-lb"]]
              awslogs-region: us-east-1
              awslogs-stream-prefix: ecs
          MemoryReservation: 512
          MountPoints: 
            - SourceVolume: qa-server-authorities
              ContainerPath: /app/ld4p/qa_server-webapp/config/authorities
          PortMappings: 
            - HostPort: 3000
              Protocol: tcp
              ContainerPort: 3000
        - Name: 'qa-mariadb'
          Cpu: 0
          EnvironmentFiles: 
            - Type: s3
              Value: !Join ["", ["arn:aws:s3:::", !Ref S3BucketName, "/", !Ref EnvFileName]]
          Essential: True
          Image: mariadb:latest
          LogConfiguration: 
            LogDriver: awslogs
            Options:
              awslogs-group: !Join ["", ["/ecs/", !Ref TaskDefinitionName, "-lb"]]
              awslogs-region: us-east-1
              awslogs-stream-prefix: ecs
          MemoryReservation: 512
          MountPoints: 
            - SourceVolume: db-mysql-data
              ContainerPath: /var/lib/mysql/data
          PortMappings: 
            - HostPort: 3306
              Protocol: tcp
              ContainerPort: 3306
      Cpu: 1024
      ExecutionRoleArn: !Join ["", ["arn:aws:iam::", !Ref AWSAccountId, ":role/ecsTaskExecutionRole"]]
      Memory: 1024
      NetworkMode: bridge
      RequiresCompatibilities: 
        - EC2
      TaskRoleArn: !Join ["", ["arn:aws:iam::", !Ref AWSAccountId, ":role/ecsTaskExecutionRole"]]
      Volumes: 
        - Name: qa-server-authorities
          EFSVolumeConfiguration:
            FilesystemId: !Ref VolumeId
            AuthorizationConfig: 
              Iam: DISABLED
              AccessPointId: !Ref AuthorityAccessPointId
            RootDirectory: "/"
            TransitEncryption: ENABLED
        - Name: db-mysql-data
          EFSVolumeConfiguration:
            FilesystemId: !Ref VolumeId
            AuthorizationConfig: 
              Iam: DISABLED
              AccessPointId: !Ref DatabaseAccessPointId
            RootDirectory: "/"
            TransitEncryption: ENABLED
  ACMCert:
    Type: AWS::CertificateManager::Certificate
    Properties:
      DomainName: !Join ["", ["*.", !Ref DomainName]]
      SubjectAlternativeNames:
        - !Ref DomainName
      ValidationMethod: DNS
  LoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      IpAddressType: ipv4
      Name: !Join ["", [!Ref TaskDefinitionName, "-lb"]]
      Scheme: internet-facing
      SecurityGroups:
# TODO: create a new security group opening 80/443 to the world and replace our pre-existing one
        # sg-9b74a3d2 = Permit TCP 80 and 443 from ANY
        - sg-9b74a3d2
# Also: what about the subnet mappings? Can we pull them from the VPC ID?
      Subnets:
        # subnet-d7ad4ca1 = cu-lit-Subnet-Public-1
        - subnet-d7ad4ca1
        # subnet-83a890da = cu-lit-Subnet-Public-2
        - subnet-83a890da
      Tags:
        - Key: Name
          Value:
            Ref: TaskDefinitionName
      Type: application
  SecurityGroupLB:
    Type: AWS::EC2::SecurityGroup
    Properties: 
      GroupDescription: Security Group to attach to the service load balancer
      GroupName: qa-server-service-group
      VpcId: !Ref AWSVpcId
  SecurityGroupCI:
    Type: AWS::EC2::SecurityGroup
    Properties: 
      GroupDescription: Security Group to attach to the container instances
      GroupName: qa-server-instance-group
      VpcId: !Ref AWSVpcId
  SecurityGroupEgressCI:
    Type: AWS::EC2::SecurityGroupEgress
    Properties: 
      IpProtocol: tcp
      FromPort: 0
      ToPort: 65535
      GroupId: !Ref SecurityGroupCI
      DestinationSecurityGroupId: !GetAtt SecurityGroupLB.GroupId
  SecurityGroupIngressCI:
    Type: AWS::EC2::SecurityGroupIngress
    Properties: 
      IpProtocol: tcp
      FromPort: 0
      ToPort: 65535
      GroupId: !Ref SecurityGroupCI
      SourceSecurityGroupId: !GetAtt SecurityGroupLB.GroupId
      SourceSecurityGroupOwnerId: !Ref AWSAccountId
  SecurityGroupEgressLB:
    Type: AWS::EC2::SecurityGroupEgress
    Properties: 
      IpProtocol: tcp
      FromPort: 0
      ToPort: 65535
      GroupId: !Ref SecurityGroupLB
      DestinationSecurityGroupId: !GetAtt SecurityGroupCI.GroupId
  SecurityGroupIngressLB:
    Type: AWS::EC2::SecurityGroupIngress
    Properties: 
      IpProtocol: tcp
      FromPort: 0
      ToPort: 65535
      GroupId: !Ref SecurityGroupLB
      SourceSecurityGroupId: !GetAtt SecurityGroupCI.GroupId
      SourceSecurityGroupOwnerId: !Ref AWSAccountId
  TargetGroup80:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckEnabled: true
      HealthCheckIntervalSeconds: 30
      HealthCheckPath: /
      HealthCheckPort: traffic-port
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 5
      Matcher:
        HttpCode: 200
        HttpCode: 302
      Name: !Join ["", [!Ref TaskDefinitionName, "-80"]]
      Port: 80
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      VpcId: vpc-5e5cfd3a
  Listener80:
    Type: 'AWS::ElasticLoadBalancingV2::Listener'
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref TargetGroup80
      LoadBalancerArn: !Ref LoadBalancer
      Port: 80
      Protocol: "HTTP"
  Listener443:
    Type: 'AWS::ElasticLoadBalancingV2::Listener'
    Properties:
      Certificates:
        - CertificateArn: !Ref ACMCert
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref TargetGroup80
      LoadBalancerArn: !Ref LoadBalancer
      Port: 443
      Protocol: "HTTPS"
      SslPolicy: "ELBSecurityPolicy-2016-08"

